(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{376:function(t,l,a){"use strict";a.r(l);var v=a(14),_=Object(v.a)({},(function(){var t=this,l=t._self._c;return l("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[l("h1",{attrs:{id:"浅谈代码的健壮性"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#浅谈代码的健壮性"}},[t._v("#")]),t._v(" 浅谈代码的健壮性 ⛪️")]),t._v(" "),l("p",[t._v("代码的健壮性，这个词老早就听说过了，但是一直没有系统的去了解过，起初的映象一直停留在，怎样提高代码的容错方面。")]),t._v(" "),l("h2",{attrs:{id:"健壮性的思想"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#健壮性的思想"}},[t._v("#")]),t._v(" 健壮性的思想")]),t._v(" "),l("ol",[l("li",[t._v("正常运行的代码.首要追求高效性")])]),t._v(" "),l("ul",[l("li",[t._v('这个"高效性"如果从逻辑的角度来解释,那么一方面是"高效"地对正确的数据执行正确的算法(方法/策略),另一方面是"高效"地找出异常,然后丢给异常处理代码去处理.')])]),t._v(" "),l("ol",{attrs:{start:"2"}},[l("li",[t._v("处理异常的代码.首要追求健壮性.")])]),t._v(" "),l("ul",[l("li",[t._v('就是程序必须能从异常中自我恢复.由于代码多数时间跑的是"正常"逻辑,少数情况下才不得不处理"异常",所以"异常"处理的代码中,首要任务是健壮,跑不死,而高效性则是次要的.')])]),t._v(" "),l("h2",{attrs:{id:"如何提高代码的健壮性"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#如何提高代码的健壮性"}},[t._v("#")]),t._v(" 如何提高代码的健壮性")]),t._v(" "),l("ol",[l("li",[t._v("在与后台进行数据交互时，数据类型返回不规范，这时前端在拿到数据后，将不规范的数据处理成规范数据，这样虽然会影响开发速度，但是在后期的代码维护或者修改Bug时会轻松很多。")])]),t._v(" "),l("ul",[l("li",[t._v("举个例子")])]),t._v(" "),l("blockquote",[l("p",[t._v('在有数据时后台将数组完整的返回给你，当该数组中没有数据时，后台如果不处理就会直接返回一个null给前端，如果前端在拿到数据时不做容错处理，直接使用该数组，相当于直接遍历了一个null，在后面编辑数组中就会出现报错。\n在使用vue时，页面再次编辑多选操作时，如果后台给的checked为字符串"true/false",就会出现页面上无法反显勾选状态，而且也不会报错，导致难以定位问题的所在。')])]),t._v(" "),l("ol",{attrs:{start:"2"}},[l("li",[l("p",[t._v("尽量少使用静态变量")])]),t._v(" "),l("li",[l("p",[t._v("尽量避免在类的构造函数里创建、初始化大量的对象")])])]),t._v(" "),l("ul",[l("li",[t._v("防止在调用其自身类的构造器时造成不必要的内存资源浪费，尤其是大对象，JVM会突然需要大量内存，这时必然会触发GC优化系统内存环境；显示的声明数组空间，而且申请数量还极大。")])]),t._v(" "),l("ol",{attrs:{start:"4"}},[l("li",[t._v("对象池技术")])]),t._v(" "),l("ul",[l("li",[t._v("尽量在合适的场景下使用对象池技术以提高系统性能，缩减缩减开销，但是要注意对象池的尺寸不宜过大，及时清除无效对象释放内存资源，综合考虑应用运行环境的内存资源限制，避免过高估计运行环境所提供内存资源的数量。")])]),t._v(" "),l("ol",{attrs:{start:"5"}},[l("li",[l("p",[t._v("大集合对象拥有大数据量的业务对象的时候，可以考虑分块进行处理，然后解决一块释放一块的策略。")])]),t._v(" "),l("li",[l("p",[t._v("不要在经常调用的方法中创建对象，尤其是忌讳在循环中创建对象。")])])]),t._v(" "),l("ul",[l("li",[t._v("可以适当的使用hashtable，vector创建一组对象容器，然后从容器中去取那些对象，而不用每次new之后又丢弃。")])]),t._v(" "),l("ol",{attrs:{start:"7"}},[l("li",[l("p",[t._v("一般都是发生在开启大型文件或跟数据库一次拿了太多的数据，造成Out Of Memory Error的状况，这时就大概要计算一下数据量的最大值是多少，并且设定所需最小及最大的内存空间值。")])]),t._v(" "),l("li",[l("p",[t._v("尽量少用finalize函数")])])]),t._v(" "),l("ul",[l("li",[t._v("因为finalize()会加大GC的工作量，而GC相当于耗费系统的计算能力。")])]),t._v(" "),l("ol",{attrs:{start:"9"}},[l("li",[t._v("不要过滥使用哈希表")])]),t._v(" "),l("ul",[l("li",[t._v("有一定开发经验的开发人员经常会使用hash表（hash表在JDK中的一个实现就是HashMap）来缓存一些数据，从而提高系统的运行速度。比如使用HashMap缓存一些物料信息、人员信息等基础资料，这在提高系统速度的同时也加大了系统的内存占用，特别是当缓存的资料比较多的时候。其实我们可以使用操作系统中的缓存的概念来解决这个问题，也就是给被缓存的分配一个一定大小的缓存容器，按照一定的算法淘汰不需要继续缓存的对象，这样一方面会因为进行了对象缓存而提高了系统的运行效率，同时由于缓存容器不是无限制扩大，从而也减少了系统的内存占用。现在有很多开源的缓存实现项目，比如ehcache、oscache等，这些项目都实现了FIFO 、MRU等常见的缓存算法。")])])])}),[],!1,null,null,null);l.default=_.exports}}]);